---
layout: home
---

# 객체와 배열, 함수의 기초
자바스크립트라는 프로그래밍 언어를 학습하기 위한 기본 개념에 대해서 설명합니다.


## 객체의 기초, 객체 리터럴
자바스크립트에시는 원시 타입을 재외한 모든 값이 객체입니다.

객체는 자바스크립트에서 가장 중요한 데어터 타입입니다. 객체는 `객체 리터럴`과 `생성자`로 생성함 수 였습니다.


### 객체란?
객체는 행동과 데이터를 묶은 데이터 타입입니다. 객체에는 여러 데이터를 같이 포함하고 있기 때문에 `복합데이터`로도 볼 수 있스빈다.

> 프로퍼티
> 객체의 데이터를 다른 말로 `프로퍼티`라고 합니다.

### 객체로 리터럴 객체 생성하기
자바스크립트는 다른 언어와 달리 객체를 `리터럴`로 생성할 수 있습니다.

```js
var card = {
    suit:"하트",   
    rank:"A"   
};
```

객체의 리터럴은 `{...}`부분을 말합니다. 객체의 리터럴은 대입연산자 대신에 콜론(:)을 사용합니다. 그리고 각각의 프로퍼티들은 콤마(,)로 구분합니다.

> 프로퍼티 이름은 식별자로 사용합니다.

프로퍼티 값에는 모든 네이터 타입의 값과 표현식을 대입 할수 있습니나.


이렇게 대입된 프로퍼티의 값은 마침표(`.`) 연산자 또는 대괄호(`[]`)  연산자를 통하여 접근할 수 있습니다.

```js
console.log(card.suit);
console.log(card["rank"]);
```

마침표로 프로퍼터를 읽거 나 쓸 때는 프로퍼티 이름을 `식별자`로 사용할 수 있습니다.
반면에, 대괄호로 프로퍼티를 읽거나 쓸 때는 프로퍼티 이름  또는 문자열을 반환한 표현식을 시용 가능합니다.

일반적으로 선언되지 않는 변수를 접근할때는 `잠조오류`가 발생되었습니다. 하지만, 개체에서는 없는 프로퍼티를 읽으려고 시도하면 `undefined`를 반환함니다.

```js
card.color    // ~ unde fi ned
```

#### 빈 객체
프로퍼티도 작성하지 않으면 빈 색체가 생성됩니디.

```js
var obj={};
console.log( obj ) ; // ➔ Obj ect{}
```

### 프로퍼티 추가와 삭제
자바스크립트는 동적으로 프로퍼티를 추가할 수 있습니다.

```js
card.value = 14 ;
console.log( card ); // ~ Object {suit: “하트", rank: "A", value : 14}
```

객체의 프로퍼티를 삭제할때에는 `delete`연산자를 사용합니다.

```js
delete card.rank ;
console.log ( card );    // 一 Object  {suit :  “하트' ,    value:  14}
```

### 프로퍼티 확인
`in` 연산자를 시용히면 객재에 특정 프로퍼티가 있는지 획인할 수 있습니다.

```
프로퍼티 이름을 뜻하는 문자열 i n  객체명
```

예를 들어 확인해 봅니다.

```js
var card = { suit : "하트" , rank : " A" }; 
console.log ( "suit " in card ); // - Uue 
console.log ( "color" in card ); // - false
```

> `in` 연산자가 조시하는 대상이 그 객재가 가진 프로퍼티와 그 객체가 상속받은 모는 프로퍼티라는 점을 주의합니다.

모든 객체는 Object 객체를 상속합니다. 그렇기 때문에 `toString`와 같은 기본 메소드들이 포함되어 있습니다.

```js
console.log("toString" in card); // - true
```

객체의 프로퍼티는 또다른 객체를 값으로 가질 수 있습니다.

```js
var circle =  {
    center : {  
        x :  1.0 ,  
        y :  2 . 0 
    }, 
    radius : 2.5
};
```

이렇게 중첩된 객체는 점을 통하여 연결하여 접근할 수 있습니다.

```js
circle.center.x
```

### 메서드
프로퍼터에 저장뒤 값의 타입이 함수면 그 프로퍼티를 메서드라고 부릅니다.


### 객체 참조
생성된 객체는 메모리의 영역을 차지하고 있습니다. 그리고 객체은 이 메모리 영역을 가리치는 참조 입니다.

변수에 저장된 객제의 `참조`는 다른 원시 값과 마찬가지로 `다른 변수`에 저장함 수 있습니디.

```js
var a = card;
```

이렇게 card 객체의 참조가 a 변수에 재저장하게 되면, 이제 a로 card의 객체를 접근할 수 있습니다.

```js
console.log( a.suit ); //  一 하드
a.suit = "스페이드";
console.log( a.suit ); // 스페이드 <= 값이 변경되었습니다.
```


## 함수의 기초
힘수는 자바스크립트 프로그래밍 언어를 규정하는 가장 중요한 구성 요소입니다.


### 함수
수학에서의 함수는 주어진 입력 값 x에 대해 출력 값 y를 대응시키는 규칙입니다

함수는 일련의 처리를 하나로 모아 언제든 호출할 수 있도록 만둘어 둔 것입니다.

함수는 입력 값을 받으면 출력 값을 반환합니 다. 

함수의 입 력 값을 `인수`라고 부르고 함수의 출력 값을 `반환값`이라고 부릅니다.

### 함수 선언 및 정의
함수는 `function` 키워드를 시용해서 정의합니디. 

```js
function square(x)  {  return  x  * x;  }
```

함수는 값을 반환 합니다. 이때 사용되는 키워드는 return 입니다.
return 문이 실행되면 제어권이 함수를 호출한 코드로 되돌아갑니다. 



### 함수 이름
변수 이름과 마찬가지로 모든 식 별자를 함수 이름으로 사용할 수 있습니다.     

> 함수 이름짓기
> 함수 이름은 해당 함수의 기능을 이해하기 쉽게 지어야 합니다.
> 함수 이름은 일반적으로 동사 또는 동사로 시작되는 어휘로 만듭니다


### 함수 호출
함수를 호출하려면 함수 이름 뒤에 소괄호로 인수를 묶어 입력합니다.

```js
square(3);
```

### 인수
함수는 인수를 여러 개 받을 수 있습니다. 
인수가 여리 개라면 인수와 인수를 쉼표(`,`)로 구是합니다.



### 실행흐름
함수의 실행 흐름은 다음과 같습니다.

* 호출한 코드에 였는 인수가 함수 정의문의 인자에 대입된다.
* 함수 정의문의 종괄호 안에 작성된 프로그램이 순차적으로 실행된다.
* return 문이 실행되면 호출한 코드로 돌아간다. return 문의 값은 함수의 반환값이 된다.
* return 문이 실행되지 않은 상태로 마지막 문장이 실행되 면, 호출한 코드로 돌아간 후에 undefined 가 함수의 반환값이 된댜


### 함수 선언문의 끌어올림
자바스크럽트 엔진은 변수 선언문과 마찬가지로 함수 선언문을 프로그램의 첫머 리로 꿀어올럽니다.

```js
console.log( square(S) );    // 함수호출

// 함수 선언
function square(x) { return x * x; }
```

### 값으로서의 함수
자바스크럽트에서는 함수가 객체 입니다.  

함수 선언문으로 함수를 선언하면 내부적으로는 그 함수 이름을 변수 이름으로 한 변수와 함수 객제가 만들어지고, 그 변수에 함수 객체의 참조가 저장됩니다.

함수를 다른 변수에 할당하여, 변수로 함수를 실행할 수 있습니다.

```js
var sq = square;
console.log( sq(S) ); // - 25
```


### 참조에 의한 호출과 값에 의한 호출
함수는 원시 값을 인수로 넘겼을 때와 객체를 인수로 넘겼을 때 다르게 동작합니다. 먼저 인수가
원시 값일 때 어떻게 동작하는지 예제를 살펴보겠습니다.

```js
function add l (x)  {  return  x  = x  +   1;  } 


var a  = 3;
var b = add l ( a );
console . log ( " a = " + a + ", b = " + b); // - a 3, b - 4
```

인수에 원시 값을 넘기면 `그 값 자체`가 인자에 전당됩니다.



#### 인수가 객체일 때 

```js
function addl(p) {
    p.x = p.x + 1;   
    p.y = p.y + 1;   
    return  p;  
} 

var a = { x : 3,  y : 4};
var b = addl( a );
console.log( a , b); 
```

함수가 호출될 때 변수 a 객체의 참조 복사본이 인자 p 에 할당됩니다.
이를 `참조 전달`이 라고 부릅니다.

함수 안에서 `p.x` 와 `p.y`를 수정하는 행위는 a.x 와 a.y를 수정하는 행위와 같습니댜


### 변수의 유효범위
변수에 접근할 수 였는 범위를 그 변수의 유효 범위(scope) 라고 합니다. 

#### 전역 유효 범위
전역 변수는 함수 바깥에서 선언된 변수로 유효 범위가 전체 프로그램입니다.

#### 지역 유효 범위
지역 변수는 함수
안에서 선언된 변수와 함수 인자로 유효 범위는 변수가 선언된 함수 내부입니다. 

#### 변수의충돌
변수에 유효 범위가 있는 이유는 프로그램의 다른 부분에서 선언된 이름이 같은 변수와 충돌 않도록 하기 위해서입니다.

```js
var  a  =  "global" ; 

function  f ()  {
    var a  =  " local " ;
    console . log ( a ) ; // - local
    return  a ;
}

f();

console . log ( a ); //~ qlobal
```

#### 함수 안에서의 변수 선언과 변수 끌어올림
함수 안에서 선언된 시역 변수의 유효 범 위는 함수 전체 입니다.
자바스크입트 엔진은 함수 안의 변수 선언부를 함수의 첫머리로 끌어옵럽니다.

#### 함수 안에서의 변수 선언 생략
변수를 선언하지 앉은 상대에서 값을 대입하면 `전역 변수`로 선언됩니다.



### 블럭 유효 범위 : let과 const
`let` 과 `const` 는 ES6 부터 추가된 변수 선언자로 모두가 `블록 유효 범위`를 가지고 있습니다.  


#### let 선언자
let 문은 블록 유효 범위를 갖는 지역 변수를 선언합니다.
> 시용법은 var 문과 같습니다.

* 자바스크립트 엔진은 var 문과 달리 let 문으로 선언한 변수를 끌어올리지 않습니다.

* let 문으로 똑같은 이름을 가진 변수를 선언하면 문법 오류가 발생합니다.


#### const 선언자

canst 문은 블록 유효 범위를 가지면서 `한 번만 할당`할 수 였는 변수(상수)를 선언합니다.


### 함수 리터럴로 함수 정의하기
함수는 함수 `리터렬`로도 정의할 수 였습니다. 

```js
var square = function (x) {  return  x  *  x;  };
```

`function(x) {...}` 부분이 함수 리터렬입니다.

> 함수 리터럴은 이릅이 없는 함수이므로 `익명 함수` 또는 `무명 함수`라고 부릅니다. 


함수 선언문에서는 끝에 세미콜론을 붙일 필요가 없지만 함수 리터렬을 사용할때는 끝에 반드시 세미콜론을 붙여야합니다.


#### 함수의 호이스팅과의 관계
함수 리터렬로 정의한 익명 함수는 변수에 할당한후에야 비로소 이름을 갖 게 되고. 
그 이름으로 호출할수 있게 됩니다.   
이러한 이유 때문에 함수를 정의하지 않은상태에서 힘수를 사용하려고 하면 타입 오류가 발생합니다.

```js
console.log( square(3) ) ;    // -  TypeEt-ror:  square  is not  a  function 
var square = function(x) { return  x * x; };
```

익명 함수에도 이름을 붙일 수 있습니다.
```js
var square = function sq (x) {  return  x *  x;  };
```
sq 라는 이름은 함수 안에서만 유효하므로 함수 바깥에서는 sq 라는 이름으로 함수를 호출할 수 없습니다


> 익명함수 코드는 디버거에 모두 `anonymous function` 이 라고 표시 되므로 함수를 구별할 수 없다는 단점 이 있습니다.     


### 객체의 메서드
객체의 프로퍼 티 중에서 함수 객체의 참조를 값으로 담고 있는 프로퍼티를 가리켜 메서드라고 부릅니다.
메서드를 정의할 때는 프로퍼티 값으로 함수 리터렬을 대입합니다.

```js
var  circle =  {
    center :  {  x : 1.0,  y: 2.0 }, 
    radiu s :  2.5 ,
    area :  function  ()  {
        return  Math . PI  * this . radius  * this . radius ;
    }
};
```
메서드는 일반직으로 메서드가 속한 객체의 내부 데이터(포로퍼티 값) 상태를 바꾸는 용도로 사용합니다.



### 함수의 장점
함수를 활용하면 다양한 효괴를-  기대할 수 였습니다.

* 재사용할수있다
* 만든 프로그램을 이해하기 쉽다
* 만든 프로그램을 이해하기 쉽다


## 객체의 기초, 생성자
생성자로 객체를 생성하는 방법을 배웁니다.
생성자를 이용하면 객제 여러 개를 효율적으로 생성할 수 있습니다.



### 생성자로 객체 생성하기
일반적으로 프로그램은 객체를 생성하기 위하여 클래스를 사용합니다. 클래스를 사용하면 프로퍼티가 똑같은 객체 를 얼마든지 만들구 수 있습니다.


하지만 자바스크립트에는 클래스가 없습니다. 
대신 생성자라고 하는 함수로 객체를 생성할 수 있습니댜


#### 객체를 생성하는 생성자

```js
function  Card(suit,  rank)  { 
    this . suit = s uit;
    this . rank  =  rank; 
}
```

생성자로 객체를 생성할 때는 new 연산자를 사용합니다.

```js
var card = new Card("하트", "A" );
```

생성자는 첫글자를 대문자로 쓰는 파스칼 표기법을 사용합니다.

생성자 안에서 `this.프로퍼티` 이름에 값을 대입하면 그 이름을 가진  프로퍼티에
값이 할당된 객체가 생성됩니다.

#### 생성자
`new` 연신시로 객체를 생성할 것아랴 기대하고 만든 함수를 `생상지`라고 부릅니다.

#### 생성자의 역할
생성자는 객체를 생성하고 초기화 하는 역할을 합니다.
   


### 메서드를 가진 객체를 생성하는 생성자
생성자에서 `this.프로퍼티` 이름에 함수의 잡조를 대입하면 메서드를 정의할 수 있습니다.

```js
function Circle(center,  radius)  {
    this.center = center;
    this.radius = radius ;
    this.area = function ()  {
        return  Math . PI  * this . radius  * this. radius ; 
    };
}

var p = {x : 0 ,  y : 0};
var c = new Circle( p, 2.0);

console . log ( "넓이 = " + c.area ()); 
```



## 객체의 기초, 내장객체
자바스크럽트에는 처음부터 시용할 수 있는 내징 객체(빌트인 오브젝트)기 마련되어 있습니다.


### 내장 생성자
자바스크립트에 지음부터 포함된 내장생성자가 있습니다.

이 생성지는 모든 자바스크립트 실행 환경에서 사용할 수 있습니다.

### Date 생성자
대표적인 내장 생성자인 Date 생성자를 알아 보도록 하겠습니다. 

Date 생성자는 날짜와 시간을 표현하는 객체를 생성합니다.

```js
var now = new Date();
```

Date 객제는 계산식 안에서 밀 리초 단위 정수로 값의 타입이 바뀝니다.

```js
var start = new Date();

/* 실행 시간을 측정할 코드를 작성하는 위치 */ 
var end = new Date();
var elapsed = end - start; //  실행에 걸리는 사간(믿리초 단위)
```

* now.getFullYear()
* now.getMonth()
* now.getDate()
* now.getDay()
* now.getHours()
* now.getMinutes()
* now.getSeconds()
* now.gctMilliseconds()        //  -  257( 시각의 임라초广 노〈하는 :  자 값)
* now.toString()                     //  ~ "Thu  Mar  17  2016  16 : 50:55  GMT+0'J00(KST)"
* now.toLocaleString()          //  4          "2016/3/17  16:50:55" （지역화된 시간가 날짜 것보)
* now.toLocaleDateString()  // -   "2016.  3.  17.”( 자역화된 닐씨 정보)
* now.toLocaleTimeString()   //  ~ "오후 4 :   50:55" （지역파된 시간 징보)
* now.getUTCHours()                // -  7(UTC( 업정 셰계 시) 시각의 시간을 :하논 숫AI  값)
* now.toUTCString()


### function 생성자
Function은 삼수를 생성하논 내장 생성자입 니다.     

```js
var square = new Function( "x",  "return x * x" );
```

섯 번째 인지인 "x" 는 인수의 이릅을 뜻히는 문시열이고 두 번쌔 인수는 함수 몸통 이 작성된 문자열 입니다.


### 기타 내장 객체
내장 객체는 내장 생성자를 통하여 생성합니다.

하지만, 일부 내장객체는 내장 생성자로 생서을 하지 않아도 사용을 할 수 있습니다.

* 전역 객체 : 프로그램 어디에서나 사용할 수 있는 객체
* JSON : JSON을 처리하는 기능을 제공
* Math : 수학적인 함수와 상수를 제공
* Relect : 프로그램의 흐름을 가로채는 기능을 제공


### 전역 객체
전역 객체의 프로퍼티는 프로그램의 어느 위치에시나 시용할 수 있습니다.

웹 브리우저가 새로운 폐이지를 읽어 들일 때마다 새로운 전역 객체기 생성됩니다.


클라이언트 측 자바스크밉트에시는 Window 객체가 전역 객체입니다.



### 자바스크립트 객체의 분류
자바스크럽트 객체는 크계 네이터브 객체. 호스트 객체,  시용자 정의 객체로 나눌 수 있습니다.

* 네이티브 객체
EMAScript 사양에 정의된 객체가 네이티브 객체 입니다. 

* 호스트 객체
자바스크립트 실행 환경에 성의된 객체가 호스트 객체 입니다.
    - 브라우저 객제
    - DOM에 정의 객체
    - Ajax를 위한 XMLHttpRequest 객체
    - HTMLS 의 각종 API

* 사용자정의 객체
자바스크립트 코드를 실행한 결과로 생성된 객체가 사용자 정의 객체입 니댜



## 배열의 기초
배열은 값의 목록으로 값마다 번호기-  매겨 져 있습니다.


### 배열 리털러로 생성하기
배열 리터럴은 쉼표로 구분한 값을 대괄호(`[]`)로 묶어서 표현합니다.

```js
var evens  =  [   2,   4 ,  6 ,  8  ];
```

`[ … ]` 부분이 배열 리터럴이며 배열 값 하나를 배열 요소라고 부릅니다.


배열 요소에는 왼쪽부터 순서대로 0 , 1, 2 ... 라는 번호가 매겨져 였습니다. 요소에 매긴 번호는 `요소 번호` 또는 `인덱스`라고 부릅니다


빈 배열이 생성됩니다.

```js
var  empty  =  [ ] ;
console.log ( empty ) ; // · [ I
```

배영 리터멀 요소의 값을 생략하면 그 요소는 생성되지 않습니다.

```js
var a  =  [ 2,     ,   4 ] ;
console . l og ( a ); II - f 2 , undefined , 4]
```

### length 프로퍼티
배열의 length 프로퍼티에는 배열 요소의 최대 인덱스 값 + 1 이 담겨 있습니다.

```js
var evens = [   2,   4,  6,  8  ] ;
evens.length ;           //  -  4
```

length 프로퍼더 값을 가리켜 배열 길이 라고 부릅니다. 

length 프로퍼터에 현재의 배열 요소 개수보다 작고 0보다 큰 정수 값을 대입하면 배열 길이가 줄어 듭니다.

```css
var  a  =  [ " A" ,   "B" ,   "C" ,   "D" ];
a.length  =  2;
console . log ( a ) ;           //  ["A",  "B"]
```

length 프로퍼 터에 그 배열 길이보다 큰 정수 값을 대입하면 배열에 새로운 요소가 추가되지 않고 
length 프로퍼터 값만 바뀝니다.


### array 생성자로 생성하기
배 열은 Array 생성자로도 생성할 수 있습니 댜

```js
var  evens  =  new  Array( 2,   4,  6 ,  8);
```

Array 생성자의 인수가 한 개고 그 값이 양의 정수면 의미가 달라집니다. 이 때 인수는 배 열 길이
를 뜻하므로 배열이 그 길이만큼 생성됩니 다.

```js
var x = new Array(3 );
console.log ( x.length) ;     // 3
```


반면 Array 생성자의 인수가 한 개고 그 값이 양의 정수가 아니 면 오류가 발생합니다. 

```js
var  x  =  new  Array( - 3);
```

### 배열 요소의 참조
특정 인덱스의 요소는 대괄호([] )  언산지를-  사용해서 읽거나 쓸 수 였습니다.

```js
evens[2]   
```

배열 요소 하나는 변수 하나로 사용할 수 었습니 다.     

### 배열은 객체
배열 요소눈 메모리의 연속된 공간에 자례대로 배치되어 있습니다.
따라서 인덱스단 지성하면 안멕스사 가리 키는 요소를 매우 빠르게 읽기나 쓸 수 있습니다.

자바스크럽트의 배열은 Array 객체이 며 객체로 배임의 
기능을 가상으로 흉내 낸 것입니다.


배열의 요소 변호로 숫자 값 내신 문자영을 시용할수 있습니다.

```js
var a = [ "A" , " B" , "(", "D" ]; 
console.log( a["2"] ); // ~ C
```

없는 대열 요소를 읽으려고 시도하면 `undefined` 가 반환됩니다.


### 배열 요소의 추가와 삭제

없는 배열 요소에 값을 대입하면 새로운 요소가추가됩니다.

```js
va r  a  =  [ "A" ,   "B" ,   "( " ]; 
a [ 3]  =  "D" ;
console. log ( a );    // ~ ["A",   "B",   "C",   "D'’ 」;
```

디음과 같이 `push` 메서드를 사용하면 요소를 배열 끝에 주가할 수 였습니다. 

```js
var a  =  [ "A" ,   "B" ,   "C" ];
a. push ( "D" );
console . log ( a );    // ➔ ["A",   "B",   "(",  "D"]
delete 연산자를 시용하면 특정 배열 요소를삭제할수였습니다. 
delete a 口] ;
console . log ( a );    // ➔ 「 'A",  und e fin ed,  "(",  "D" ]
```

delete 연산자를 사용하여 배열의 요소를 삭제해도 그 배열의 length 프로퍼터 값은 바뀌지 않습니다. 즉, 삭제한 요소만 사라집니다.

### 희소배열
배열에 요소를 추가하거나 제거하면 인덱스가 0부터 시작되지 않는 배열이 만들어집니다. 이러한
배열을 희소 배열이라고 부릅니다. 

```js
var a  =   [ " A" ,   "B" ,   " C" ]; 
a [ 4 )  =  "E " ;
console . log (a ); // - ["A", "B", "C", undefined, "E''J;
```

실행하여 결과를 보면 a[3] 이 undefined 라고 표시되지만 실제로 저 요소는 없습니다.

>  희소 배열의 길이는 배열 요소의 개수보다 큽니다.     

> 배열 요소가 있는지 확인하기
> 배열 요소가 있는지 확인하는 방법은 객체의 프로퍼티가 있는지 확인하는 방법과 같습니다. 즉, for/in 문이나 
hasOwnProperty 메서드를 사용해서 확인할 수 있습니다.
```js
for  (var  i   in a )  conso l e . log  ( i );
a . hasOwnProperty ( "3" );
a . hasOw nProperty ( "4" ) ;
```